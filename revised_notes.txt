MDN doc , for original from ECMAscript .

why different Extensions ?
with some extension , software(compiler or interpreter) will know what syntax means. 

initially , JS was written on the web browsers and software was not common.
we will use the NODE js to LEARN JS.

JS is interpreted.

TERMINAL Query :
1) node -v :: to see node version
2) node folder_name/file_name.js :: to interpret code.             *****

VARIABLE'S AND CONSTANT'S
 const keyword for constants.
 let or var keyword for variables.
 even without let or var , we can declare variables.
 (recommended : to use 'let' for variables only)

TO PRINT OUTPUT :
    console.log(variable_name);
    console.table([variable1 ,var2 , var3 , ..]);
        it will print in the table with column names as index and values.
        in the matrix.

Initally , js syntax / code was different . Developers changes it.
To use only the newer version ,' "use strict"; ' After this only newer version will work.
but now majority is newer version.

Primitive Data Types : number , string , boolean ,etc . All with small letter.
NonPrimitive Data Types : object like arrays , inbuilt ojbects : Number ,String , Boolean , etc.
                        All with capital letter.

Data Types 
   1)in primitive DT (7 types): number , string , bigint , boolean , null , undefined , symbol. 
        //Capital first letter for all.
    null : it is dataType and standlone Value (means it also a data type )
    undefined : variable declared but not initialized with the dataType.
    symbol : to make value unique (will use in react)
    **decimals also comes under number.
   2)in non-pri DT : only object . eg) array, functions.

(difference b/w primi and non primi)   ->diff is how stored in memory and accessed.
Primitive data types are call by value.
NonPrimitive or referenced are call by reference.
(i know there meaning)

example of symbol : const id = symbol('123');
                    const anotherId = symbol('123');
                    here the id's are differnt.
                    check log(id == anotherId) :: false
                    same value still different.
example of bigint : use n at the end
                    const bignum = 233423424535322n

arrays , object and functions example:
    const arr = ["shaktiman" , "naagraj" , "doga"];
    let obj = {    //even without variable , we can use the array only use the {}
        name : "hitesh" ,
        age : 22.
    }   //all objects are declared in the { } braces.
    const func = fucntions(){    //can be declared without variable.
        console.log("hello world");
    }

To check Type : use operator typeof.
    console.log(typeof null)  //o/p OBJECT  (asked in interview)   IMP
    console.log(typeof undefined)  //o/p undefined (interview)
    variable uninitialized will be undefined.
    *you can also use syntax : typeof (score) or typeof score
    for the null : ans you can say that the ecma organisation has setted the rules for scripting languages which js follows. 
    *for function : it comes function (it is actually called function object)
    // all other non primitive data type -> comes object.

DATA CONVERSION : syntax : let varA = DataTypeObject(varB)
 1) to number 
    some non convertable's -> will get converted But the value can be NaN or else wrong.
    syntax : let var2 = Number(var1);
    cases) (string & boolean)
        "33" -> will be number and with value 33
        "33a" -> number with value NaN
        true -> 1 and false -> 0
 2) to boolean 
    Syntax : let var2 = Boolean(var1);
    cases ) (string & number)    
        "" (empty string) -> false
        else eg) "hites" -> true
        for number : for 0 : false
                     for all other : true     
 3)to string
    for number to string
    33 -> "33"

Operations :
 1)power : 2**3 is 2^3.
 2)str concatenation : str3 = str1+str2
 3)IMP : 
    console.log("1"+2+2); //answer 122 
    console.log(1+2+"2"); //answer 32

    console.log(+true); //answer 1
    // console.log(true+)  not possible
    console.log(+""); //answer 1
    // console.log(""+);  not possible
 4) prefix and postfix 

JS is dynamically Typed language (where we don't have to define the type of varaible.)
All types are assigned at run-time.

How memory work in the JS?
stack(all primitive)   Heap(non primitive)
if stack is used then the copy is provided.(not original)
if Heap is used then the original/reference is provided(change will reflect in it)
*to see this check 04A_dataType_summary.js
**variable of non primitive DT is still in the stack. But memory is in the HEAP.

STRINGS :
